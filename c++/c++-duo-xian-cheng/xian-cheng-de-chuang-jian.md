# 线程的创建

线程只是一个执行单元，它是依靠进程提供的资源才能执行；



主线程介绍：一个程序执行起来就是一个进程。而main函数就是主线程，一旦主线程执 行完毕，主线程结束，整个进程就会结束。

子线程介绍：在一个线程执行时，我们可以创建出另外一个线程。两个线程各自执行，互不干涉。注意，当主线程执行完毕，就会强制结束所有子线程，然后进程结束，从这个角度 来说，可以认为子线程是主线程的辅助线程。但是要明白主线程和子线程是平级的，只不 过主线程执行完毕后会给所有子线程发送一个信号，使所有子线程强制结束。

子线程的创建方式：很简单，直接使用thread类就可以了。 括号中只要是一个可调用对象就没有问题了。



子线程创建后如果就不管了，那么会出现非常严重的问题。&#x20;

(1) 有些子线程负责对部分数据的处理，主线程必须要等到子线程处理完毕才能继续执行，所以join函数就诞生了。 使用了join函数后，主线程就会处于挂起状态，直到子线程执行完毕才可以继续执 行。&#x20;

(2) 有些子线程和主线程完全分离，各自执行各自的。但主线程执行完毕，子线程就会立马被强制结束，容易导致各种bug，查都不知道从哪里开始查。于是 deatch函数就诞生了。detach()函数可以让子线程被 C++运行库接管，就算主线程执行完毕，子线程也会 由C++运行时库清理相关资源。保证不会出现各种意想不到的bug。



总结：子线程创建出来后，我们必须得对其进行join或者detach处理，如果主线程需要等待子线程，那就使用join，否则就是用detach；





相关代码

```cpp
#include <iostream>
#include <thread>


#if 1   // 案例1 子线程负责对部分数据的处理，主线程必须要等到子线程处理完毕后才能继续执行
        // 使用join函数，主线程会处于挂起状态，直到子线程执行完毕，join进来之后，主线程继续执行；
int main()
{
    int i = 0;
    std::cout << "main thread: i = " << i << std::endl;
    std::thread myThread([&]() {
        std::cout << "son thread: change i" << std::endl;
        i = 10;
        });
    myThread.join();
    std::cout << "main thread: i = ";
    std::cout << i << std::endl;
    return 0;
}
#endif


#if 0   // 案例2 子线程和主线程任务完全分离，如果主线程执行完毕，子线程的资源会被回收，报错
        // 所以解决办法使用detach函数
int main()
{
    std::thread myThread([]() {
        for (int i = 0; i < 100000; i++) {

        };
        });
    myThread.detach();
    std::cout << "main thread finish" << std::endl;
   
}
#endif
```
